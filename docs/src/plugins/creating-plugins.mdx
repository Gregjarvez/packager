---
name: Creating Plugins
route: /plugins/creating-plugins
menu: Plugins
---

import { ApiProps } from "~components/ApiProps";
import { Note } from "~components/Note";

# Creating Plugins

Packager supports adding custom plugins in a form of [hooks](#hooks) that get fired in a sequential order.

## Simplest plugin

Creating a plugin is super simple. Let's take a look at the simplest plugin that you can write.

```js
const tinyPlugin = {
    name: "tiny-plugin",
    extensions: [".ts", ".tsx"]
};
```

That's it, seriously. It does absolutely nothing for us so let's build something more complex and usable.
But first, you may be wondering why we need `name` and `extensions` properties? Well, there are only 2 required properties when creating a plugin and they are (you guessed it) `name` and `extensions`. Trying to register a plugin without one of them, will throw an error.

There are of course other properties (or hooks) that you may add to your plugin to give it some super powers.

## Properties

#### name

This property is used primarily for displaying more descriptive error messages and internally, to keep track of transpilers and a few other things that you'll learn below ðŸ‘‡

<ApiProps type="string" required="true" />

```js usage=true
const amazingPlugin = {
    name: "amazing-plugin"
    // ...
};
```

#### extensions

Extensions property is required because Packager uses it to determine which types of files it should call the hooks on. Without it, it would call the hooks on every single file that passes through it and 99% of time, this is not what we want.

<ApiProps type="string[]" required="true" />

```js usage=true
const amazingPlugin = {
    // ...
    extensions: [".js", ".jsx", ".ts", ".tsx"]
    // ...
};
```

<Note>Note that extensions have dots in them.</Note>

#### transpiler

Transpiler is a Class object which is responsible for transpiling code and is arguably the most important part in a plugin. At its core, every transpiler has a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) to offload the transpilation process from the UI thread.  
Head over to [Creating a Transpiler]('/plugins/creating-a-transpiler') to see how to create one.

<ApiProps type="Transpiler" required="false" />

```js usage=true
import MyTranspiler from "./MyTranspiler";

const amazingPlugin = {
    // ...
    transpiler: MyTranspiler
    // ...
};
```

## Hooks

There are 3 hooks that your plugin can use - `resolver`, `loader` and `beforeBundle`.

<Note>
    Hooks are fired only for files with extensions supplied in the extensions
    property.
</Note>

#### resolver

Resolvers are your plugin's entry point and are used to verify whether a file (or package) that is being imported actually exists. It's quite possible that you'll never need to use this hook because Packager comes with very powerful resolvers capable of resolving even NPM dependencies but of course, you'll need to first include them first.

Every resolver should resolve a full path to the file so that it's easier to retrieve a particular in the `loader` hook.

Returning `null` will defer to the next resolver function in line and if there isn't one, it will ignore this file and you will most likely get an error because the imported file/package won't be resolved.

For more information, see [Rollup's docs for resolvers](https://rollupjs.org/guide/en/#hooks).

<ApiProps
    type="(moduleId: string, parentId: string | undefined) => string | null | void | { id: string, syntheticNamedExports?: boolean | null }"
    required="false"
/>

```js usage=true
import { resolve, dirname } from "./path-utils";

const amazingPlugin = {
    // ...
    resolver(moduleId: string, parentId?: string): string | never {
        if (!parentId) {
            // This will be the entry file
            return moduleId;
        }

        const file = this.files.find(
            f => f.path === resolve(dirname(parentId), moduleId)
        );

        if (!file) {
            throw new Error("File could not be resolved.");
        }

        return file.path;
    }
    // ...
};
```

#### loader

Once a file has been resolved, we can load that particular file from anywhere we want. It can be the built-in FS on `this.files` or you could fetch a file from a CDN like [UNPKG](https://unpkg.com) or [JSDELIVR](https://www.jsdelivr.com).

For more information, see [Rollup's docs for loaders](https://rollupjs.org/guide/en/#hooks).

<ApiProps
    type="(moduleId: string) => string | null | void | { id: string, map?: string | SourceMap, syntheticNamedExports?: boolean | null }"
    required="false"
/>

```js usage=true
import { PluginLoaderResult } from "packager/types";

const amazingPlugin = {
    // ...
    loader(moduleId: string): PluginLoaderResult | never {
        const file = this.files.find(f => f.path === moduleId);

        if (!file) {
            throw new Error("File could not be loaded.");
        }

        return {
            code: file.code
        };
    }
    // ...
};
```

#### beforeBundle

This hook fires right before Packager is done bundling the code. It's useful if you want to add a piece of code in the final bundle.

If your plugin has a `transpiler`, the code that is fed into this hook is what comes out of the transpiler.

<ApiProps type="(code: string) => string | void" required="false" />

```js usage=true
const amazingPlugin = {
    // ...
    beforeBundle(code: string): string {
        return `function wrapCode () {
            ${code}
        }`;
    }
};
```

## Registering your plugin
